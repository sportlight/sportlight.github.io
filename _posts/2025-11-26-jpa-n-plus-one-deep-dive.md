---
title: JPA 성능 최적화 - 과도한 쿼리 발생 원인 분석과 해결 전략
date: 2024-05-20 12:00:00 +0900
categories: [Backend, Performance]
tags: [jpa, optimization, architecture, database]
---

## 배경

커머스 플랫폼의 '주문 관리 대시보드' 기능을 고도화하는 과정에서 성능 이슈가 발생했습니다.
관리자는 한 화면에서 주문 목록(`Order`)을 보면서, 각 주문에 포함된 배송 정보(`Delivery`)와 주문 상품 상세(`OrderItem`)를 함께 확인해야 했습니다.

개발 초기 로컬 환경에서는 문제가 없었으나, 스테이징 환경에서 데이터가 10,000건 이상 적재되자 API 응답 속도가 3초 이상 지연되는 현상이 나타났습니다.

## 문제 인식

단순히 응답이 느린 것을 넘어, 애플리케이션과 데이터베이스 사이에서 비정상적인 트래픽이 감지되었습니다. 하이버네이트 SQL 로그를 활성화하여 분석한 결과, **단 한 번의 API 요청에 수백 개의 쿼리가 실행**되고 있었습니다.

### 실제 발생한 쿼리 로그
```sql
-- 1. 주문 목록 100개를 조회하는 최초 쿼리
SELECT * FROM orders LIMIT 100;

-- 2. 이후, 각 주문에 연관된 배송 정보를 가져오기 위해 100번의 추가 쿼리 발생
SELECT * FROM delivery WHERE id = 1;
SELECT * FROM delivery WHERE id = 2;
...
SELECT * FROM delivery WHERE id = 100;

현상 정의 (N+1 문제)이것은 ORM 기술 사용 시 가장 빈번하게 발생하는 N+1 문제입니다.상위 엔티티(Order)를 조회하는 쿼리 1번(1)이 실행된 후, 조회된 데이터 수(N)만큼 연관 엔티티(Delivery)를 조회하는 추가 쿼리(N)가 발생하는 현상입니다.결국 1번의 통신으로 끝날 작업이 $1 + N$ 번의 통신으로 늘어나면서, DB 커넥션 풀을 고갈시키고 네트워크 대역폭을 낭비하는 주원인이 되었습니다.기술적 심층 분석왜 이런 비효율적인 동작이 발생했는지, 그리고 이것이 왜 치명적인지 기술사 관점에서 분석했습니다.1. 프록시 객체의 초기화 시점JPA는 엔티티를 조회할 때 연관된 객체를 즉시 가져오지 않고, 가짜 객체인 프록시를 채워 넣습니다(지연 로딩).문제는 비즈니스 로직에서 order.getDelivery().getStatus() 처럼 실제 데이터를 사용하는 순간, 영속성 컨텍스트는 비로소 DB에 쿼리를 날려 프록시를 진짜 데이터로 대체합니다. 루프를 돌며 이 작업을 수행하면 쿼리 폭탄이 터지게 됩니다.2. 네트워크 왕복 시간(RTT)의 누적쿼리 자체의 실행 속도보다 더 큰 문제는 네트워크 왕복 시간입니다.DB 서버가 아무리 빨라도, 애플리케이션 서버와 DB 서버 사이를 오가는 물리적인 시간은 줄일 수 없습니다.만약 RTT가 1ms이고 쿼리가 1000번 발생한다면, 순수하게 네트워크 대기 시간만 1초(1000ms)가 소모됩니다. 이는 시스템 전체의 처리량을 심각하게 저하시킵니다.해결 및 적용이 문제를 해결하기 위해 고려한 3가지 전략과, 최종적으로 선택한 방법을 정리했습니다.전략 1: 페치 조인 (Fetch Join)JPQL의 join fetch 구문을 사용하여, SQL의 조인(Join) 기능을 통해 연관된 데이터를 한 번에 가져오는 방식입니다.
